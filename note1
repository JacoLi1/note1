using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;

namespace PLM
{
    internal class CVYR
    {
        static int tempj, tempk;
        static byte lowerByte;
        static byte upperByte;
        static byte chksum;
        static byte[] send = new byte[10];
        static byte[] dataVal;
        static int LenValue;
        public static byte[] dataBytes = new byte[16];


        #region Timer
        private static int TIME_OUT = 0;
        private static System.Timers.Timer tmrTimeOut;
        public static void StartTimer(int millisecond)
        {

            TIME_OUT = 1;
            // Create a timer with a ten second interval.
            tmrTimeOut = new System.Timers.Timer();

            // Hook up the Elapsed event for the timer.
            tmrTimeOut.Elapsed += new ElapsedEventHandler(tmrTimeOut_Tick);

            // Set the Interval to 2 seconds (2000 milliseconds).
            tmrTimeOut.Interval = millisecond;
            tmrTimeOut.Enabled = true;
        }

        private static void tmrTimeOut_Tick(object source, ElapsedEventArgs e)
        {
            TIME_OUT--;
            if (TIME_OUT == 0)
            {
                tmrTimeOut.Stop();
            }

        }

        #endregion

        #region Command Table
        public const short cmd_Reset = 0x00;            //Reset
        public const short cmd_Initial = 0x01;           //Initialize
        public const short cmd_EqpStRd = 0x02;           //Equipment Status Reading
        public const short cmd_rdID_ASCII = 0x04;         //ASCII ID reading
        public const short cmd_rdID_Bin = 0x05;          //Binary ID reading
        public const short cmd_Origin = 0x10;       //Homing Start Command
        public const short cmd_rtt_Cont = 0x11;     //Continuous rotation Start
        public const short cmd_pst_Relt = 0x12;     //Relative Positioning Start
        public const short cmd_pst_Aslt = 0x13;     //Absolute Positioning Start
        public const short cmd_stop_Decelerate = 0x16;  //Deleceration Stop
        public const short cmd_stop_Immediate = 0x17;   //Innediate Stop
        public const short cmd_set_crrPst = 0x20;  //Current Position Setting
        public const short cmd_set_freq_HI = 0x21;  //Highest Frequency Setting
        public const short cmd_set_freq_StartUp = 0x22; //Start-Up Frequency Setting
        public const short cmd_set_rate_AccDec = 0x23;  //Acceleration & Deceleration Setting

        #endregion

        #region Error Message
        //initial error

        //Motor_AW
        public const int errInit_AW = -142;           
        public const int errInit_Reset_AW = -147;           
        public const int errInit_Init_AW = -148;           
        public const int errInit_HomePattern_AW = -149;         
        public const int errInit_Freq_AW = -150;           
        public const int errInit_SysSetting_AW = -151;           

       //Motor_1
        public const int errInit_Mtr1 = -143;           
        public const int errInit_Reset_Mtr1 = -152;
        public const int errInit_Init_Mtr1 = -153;
        public const int errInit_SysSetting_Mtr1 = -154;   

        //Motor_2
        public const int errInit_Mtr2 = -144;           
        public const int errInit_Reset_Mtr2 = -155;
        public const int errInit_Init_Mtr2 = -156;
        public const int errInit_SysSetting_Mtr2 = -157;  

        //Motor_3
        public const int errInit_Mtr3 = -145;           
        public const int errInit_Reset_Mtr3 = -158;
        public const int errInit_Init_Mtr3 = -159;
        public const int errInit_SysSetting_Mtr3 = -160;  

        //Motor_4
        public const int errInit_Mtr4 = -146;           
        public const int errInit_Reset_Mtr4 = -161;
        public const int errInit_Init_Mtr4 = -162;
        public const int errInit_SysSetting_Mtr4 = -163;   

        #region 1. Communication Status
        //return 0 = OK, 1 = Error
        public const short errCOM = 0x07;                //BIT 7:Communication Error 
        public const short errSysState = 0x06;           //BIT 6:It always return 0 if this function is not implemented
        public const short errCMD = 0x05;                //BIT 5:A command is not set after the command is sent/ data is invalid
        public const short rsv_CS_Bit4 = 0x04;           //BIT 4:Reservation. It always return to 0
        public const short rsv_CS_Bit3 = 0x03;           //BIT 3:Reservation. It always return to 0
        public const short abnDriver = 0x02;             //BIT 2:Alarm Occurrence, directive command 42
        public const short errExe = 0x01;                //BIT 1:Execute command is error
        public const short opMotorState = 0x00;          //BIT 0: Motor running is 1, Stop is 0
        #endregion

        #region 2.Equipment Status
        //Command 0x02 
        public const short rsv_ES_Bit15 = 0x0F;
        public const short rsv_ES_Bit14 = 0x0E;
        public const short rsv_ES_Bit13 = 0x0D;
        public const short input_EMG = 0x0C;
        public const short rsv_ES_Bit11 = 0x0B;
        public const short rsv_ES_Bit10 = 0x0A;
        public const short errHoming = 0x09;
        public const short sys_Setting = 0x08;

        public const short lmtSensor_Ngt = 0x07;
        public const short lmtSensor_Pst = 0x06;
        public const short rsv_ES_Bit6 = 0x05;
        public const short org_Sensor = 0x04;
        public const short exct_Monitor = 0x03;
        public const short outputMotor = 0x02;
        public const short rsv_ES_Bit1 = 0x01;
        public const short rotate_Motor = 0x00;

        #endregion

        #endregion
   
        #region Initial Devices
     //   static int stInit = 0;
        public static int Initial()
        {
            int ret = -1;
            ret = initial_motor_AW();
            if (ret == 0)
            {
                Thread.Sleep(100);
                ret = initial_motor_1();
                if (ret == 0)
                {
                    Thread.Sleep(100);

                    ret = initial_motor_2();
                    if (ret == 0)
                    {
                        Thread.Sleep(100);

                        ret = initial_motor_3();
                        if (ret == 0)
                        {
                            Thread.Sleep(100);

                            ret = initial_motor_4();
                            if (ret == 0){  ret = 0;  }
                            else{ 
                                //ret = errInit_Mtr4;
                            }
                        }
                        else{  // ret = errInit_Mtr3;
                        }
                    }
                    else {  
                        //ret = errInit_Mtr2;
                    }
                }
                else
                { //ret = errInit_Mtr1;
                }
            }
            else 
            { 
              //  ret = errInit_AW; 
            }

            return ret;
        }

        public static int initial_motor_AW()
        {
            int ret = -1;
            byte[] bytes;
            byte readCommst;
            byte devNo = 0x00;

            //Check Status
            bytes = CVYR.Write(devNo, 0x02, 0);  //Check Status
            CVYR.Send(bytes);
            bytes = Receive_Bytes();
            if (bytes[2] != 0 || bytes[3] != 12 || bytes[4] != 0 )
            {
                bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                CVYR.Send(bytes);
                //Thread.Sleep(100);

                bytes = Receive_Bytes();
                if (bytes == null) return errInit_Reset_AW;
                readCommst = bytes[2];
                if (readCommst == 0)
                {
                    bytes = CVYR.Write(devNo, 0x01, 0);  //inital
                    CVYR.Send(bytes);
                    //  Thread.Sleep(100);

                    bytes = Receive_Bytes();
                    if (bytes == null) return errInit_Init_AW;
                    readCommst = bytes[2];
                    if (readCommst == 0)
                    {
                        bytes = CVYR.Write(devNo, 0x36, 6);  //Home Patt: Bwd= 6, Fwd =4
                        CVYR.Send(bytes);
                        //    Thread.Sleep(100);

                        bytes = Receive_Bytes();
                        if (bytes == null) return errInit_HomePattern_AW;
                        readCommst = bytes[2];
                        if (readCommst == 0)
                        {
                            bytes = CVYR.Write(devNo, 0x21, 4000); //Frq set
                            CVYR.Send(bytes);
                            //      Thread.Sleep(100);

                            bytes = Receive_Bytes();
                            if (bytes == null) return errInit_Freq_AW;
                            readCommst = bytes[2];
                            if (readCommst == 0)
                            {
                                bytes = CVYR.Write(devNo, 0x39, 0); //sys set
                                CVYR.Send(bytes);
                                //        Thread.Sleep(100);

                                bytes = Receive_Bytes();
                                if (bytes == null) return errInit_SysSetting_AW;
                                readCommst = bytes[2];
                                if (readCommst == 0) { ret = 0; }
                                else { ret = errInit_SysSetting_AW; }
                            }
                            else { ret = errInit_Freq_AW; }
                        }
                        else { ret = errInit_HomePattern_AW; }
                    }
                    else { ret = errInit_Init_AW; }
                }
                else { ret = errInit_Reset_AW; }
            }
            else
            {
                ret = 0;
            }

            return ret;
        }

        public static int initial_motor_1()
        {
            int ret = -1;
            byte[] bytes;
            byte readCommst;
            byte devNo = 0x01;


            //Check Status
            bytes = CVYR.Write(devNo, 0x02, 0);  //Check Status
            CVYR.Send(bytes);
            bytes = Receive_Bytes();
            if (bytes[2] != 0 || bytes[3] != 12 || bytes[4] != 0)
            {

                bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                CVYR.Send(bytes);
                //      Thread.Sleep(100);

                bytes = Receive_Bytes();
                if (bytes == null) { return errInit_Reset_Mtr1; }
                readCommst = bytes[2];
                if (readCommst == 0)
                {
                    bytes = CVYR.Write(devNo, 0x01, 0);  //inital
                    CVYR.Send(bytes);
                    //        Thread.Sleep(100);

                    bytes = Receive_Bytes();
                    if (bytes == null) { return errInit_Init_Mtr1; }
                    readCommst = bytes[2];
                    if (readCommst == 0)
                    {
                        bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                        CVYR.Send(bytes);
                        //          Thread.Sleep(100);

                        bytes = Receive_Bytes();
                        if (bytes == null) { return errInit_SysSetting_Mtr1; }
                        if (bytes[2] != 0)
                        {
                            bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                            CVYR.Send(bytes);
                            bytes = Receive_Bytes();
                            if (bytes == null) { return errInit_Reset_Mtr1; }
                            readCommst = bytes[2];
                            if (readCommst == 0)
                            {
                                bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                                CVYR.Send(bytes);
                                bytes = Receive_Bytes();
                            }
                        }
                        readCommst = bytes[2];
                        if (readCommst == 0) { ret = 0; }
                        else { ret = errInit_SysSetting_Mtr1; }
                    }
                    else { ret = errInit_Init_Mtr1; }
                }
                else { ret = errInit_Reset_Mtr1; }
            }
            else
            {
                ret = 0;
            }


            return ret;
        }

        public static int initial_motor_2()
        {
            int ret = -1;
            byte[] bytes;
            byte readCommst;
            byte devNo = 0x02;

            //Check Status
            bytes = CVYR.Write(devNo, 0x02, 0);  //Check Status
            CVYR.Send(bytes);
            bytes = Receive_Bytes();
            if (bytes[2] != 0 || bytes[3] != 12 || bytes[4] != 0)
            {

                bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                CVYR.Send(bytes);
                //      Thread.Sleep(100);

                bytes = Receive_Bytes();
                if (bytes == null) { return errInit_Reset_Mtr2; }
                readCommst = bytes[2];
                if (readCommst == 0)
                {
                    bytes = CVYR.Write(devNo, 0x01, 0);  //inital
                    CVYR.Send(bytes);
                    //        Thread.Sleep(100);

                    bytes = Receive_Bytes();
                    if (bytes == null) { return errInit_Init_Mtr2; }
                    readCommst = bytes[2];
                    if (readCommst == 0)
                    {
                        bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                        CVYR.Send(bytes);
                        //          Thread.Sleep(100);

                        bytes = Receive_Bytes();
                        if (bytes == null) { return errInit_SysSetting_Mtr2; }
                        if (bytes[2] != 0)
                        {
                            bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                            CVYR.Send(bytes);
                            bytes = Receive_Bytes();
                            if (bytes == null) { return errInit_Reset_Mtr2; }
                            readCommst = bytes[2];
                            if (readCommst == 0)
                            {
                                bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                                CVYR.Send(bytes);
                                bytes = Receive_Bytes();
                            }
                        }
                        readCommst = bytes[2];
                        if (readCommst == 0) { ret = 0; }
                        else { ret = errInit_SysSetting_Mtr2; }
                    }
                    else { ret = errInit_Init_Mtr2; }
                }
                else { ret = errInit_Reset_Mtr2; }
            }
            else
            {
                ret = 0;
            }

            return ret;
        }

        public static int initial_motor_3()
        {
            int ret = -1;
            byte[] bytes;
            byte readCommst;
            byte devNo = 0x03;

            //Check Status
            bytes = CVYR.Write(devNo, 0x02, 0);  //Check Status
            CVYR.Send(bytes);
            bytes = Receive_Bytes();
            if (bytes[2] != 0 || bytes[3] != 12 || bytes[4] != 0)
            {

                bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                CVYR.Send(bytes);
                //   Thread.Sleep(100);

                bytes = Receive_Bytes();
                if (bytes == null) { return errInit_Reset_Mtr3; }
                readCommst = bytes[2];
                if (readCommst == 0)
                {
                    bytes = CVYR.Write(devNo, 0x01, 0);  //inital
                    CVYR.Send(bytes);
                    //        Thread.Sleep(100);

                    bytes = Receive_Bytes();
                    if (bytes == null) { return errInit_Init_Mtr3; }
                    readCommst = bytes[2];
                    if (readCommst == 0)
                    {
                        bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                        CVYR.Send(bytes);
                        //          Thread.Sleep(100);

                        bytes = Receive_Bytes();
                        if (bytes == null) { return errInit_SysSetting_Mtr3; }
                        if (bytes[2] != 0)
                        {
                            bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                            CVYR.Send(bytes);
                            bytes = Receive_Bytes();
                            if (bytes == null) { return errInit_Reset_Mtr3; }
                            readCommst = bytes[2];
                            if (readCommst == 0)
                            {
                                bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                                CVYR.Send(bytes);
                                bytes = Receive_Bytes();
                            }
                        }
                        readCommst = bytes[2];
                        if (readCommst == 0) { ret = 0; }
                        else { ret = errInit_SysSetting_Mtr3; }
                    }
                    else { ret = errInit_Init_Mtr3; }
                }
                else { ret = errInit_Reset_Mtr3; }
            }
            else
            {
                ret = 0;
            }

            return ret;
        }

        public static int initial_motor_4()
        {
            int ret = -1;
            byte[] bytes;
            byte readCommst;
            byte devNo = 0x04;

            //Check Status
            bytes = CVYR.Write(devNo, 0x02, 0);  //Check Status
            CVYR.Send(bytes);
            bytes = Receive_Bytes();
            if (bytes[2] != 0 || bytes[3] != 12 || bytes[4] != 0)
            {

                bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                CVYR.Send(bytes);
                //    Thread.Sleep(100);

                bytes = Receive_Bytes();
                if (bytes == null) { return errInit_Reset_Mtr4; }
                readCommst = bytes[2];
                if (readCommst == 0)
                {
                    bytes = CVYR.Write(devNo, 0x01, 0);  //inital
                    CVYR.Send(bytes);
                    //      Thread.Sleep(100);

                    bytes = Receive_Bytes();
                    if (bytes == null) { return errInit_Init_Mtr4; }

                    readCommst = bytes[2];
                    if (readCommst == 0)
                    {
                        bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                        CVYR.Send(bytes);
                        //        Thread.Sleep(100);

                        bytes = Receive_Bytes();
                        readCommst = bytes[2];
                        if (bytes == null) { return errInit_SysSetting_Mtr4; }

                        if (bytes[2] != 0)
                        {
                            bytes = CVYR.Write(devNo, 0x00, 0);  //reset
                            CVYR.Send(bytes);
                            bytes = Receive_Bytes();
                            if (bytes == null) { return errInit_Reset_Mtr4; }
                            readCommst = bytes[2];
                            if (readCommst == 0)
                            {
                                bytes = CVYR.Write(devNo, 0x39, 0);  //sys set
                                CVYR.Send(bytes);
                                bytes = Receive_Bytes();
                            }
                        }
                        if (readCommst == 0) { ret = 0; }
                        else { ret = errInit_SysSetting_Mtr4; }
                    }
                    else { ret = errInit_Init_Mtr4; }
                }
                else { ret = errInit_Reset_Mtr4; }
            }
            else
            {
                ret = 0;
            }

            return ret;
        }
        #endregion

        #region Origin
        public static Thread thr_OrgAW;
        public static int StartOrigin()
        {
            int ret = 0;
            byte[] bytes;
            bytes = CVYR.Write(0x00, 0x10, 0);
            CVYR.Send(bytes);
            return ret; 
        }

        internal static int In_Pst_Move()
        {
            int ret = -1;
            byte[] bytes;
            bytes = CVYR.Write(0x00, 0x02, 0);
            CVYR.Send(bytes);
            bytes = CVYR.Receive_Bytes();
            byte byteslow = bytes[4];

            if ((byteslow & 0x01) == 0x01)
            {
                bytes = CVYR.Write(0x00, 0x02, 0);
                CVYR.Send(bytes);
                bytes = CVYR.Receive_Bytes();
                byteslow = bytes[4];
            }
            else
            {
                ret = 0;
            }
            return ret;

        }
        #endregion

        #region Calculation
        //Calculation for homing pattern
        public static byte[] cvyr_homingPattern(int paraNo)
        {
            String ConvHex = paraNo.ToString("X2");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
            return bytes;
        }

        //Calculation for Movement Distance
        public static byte[] cvyr_calDistance(double paraNo)
        {
            int DecCal = (int)((paraNo) * 400.00);
            String ConvHex = DecCal.ToString("X8");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
             
            return bytes;
        }

        //Calculation for Frequency Setting
        public static byte[] cvyr_calFreq(int paraNo)
        {
            String ConvHex = paraNo.ToString("X4");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
            return bytes;
        }

        //Calculation for Hi/low-Velocity Setting   //Cmd
        public static byte[] cvyr_calVelocitySetting(int paraNo)
        {
            int cal = paraNo / 6;
            String ConvHex = cal.ToString("X2");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
            return bytes;
        }

        //Calculation for Acc/Deacc-Time Setting  //Cmd62 or Cmd 63
        public static byte[] cvyr_calAccTimeSetting(int paraNo)
        {
            int cal = paraNo / 10;
            String ConvHex = cal.ToString("X2");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
            return bytes;
        }

        //Calculation for Hi-Spd Setting //Cmd 68 or Cmd 69
        public static byte[] cvyr_calSpdSetting(int paraNo)
        {
            String ConvHex = paraNo.ToString("X2");
            byte[] bytes = Enumerable.Range(0, ConvHex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(ConvHex.Substring(x, 2), 16))
                             .ToArray();
            bytes = bytes.Reverse().ToArray();
            return bytes;
        }


        #endregion

        #region Generate Data Package
        //Generate Send Data Command
        public static byte[] cvyr_dataCommand(byte devNo, byte cmd, double paraNo)
        {
            int i;
            tempj = 0;
            tempk = 0;
            lowerByte = 0;
            upperByte = 0;
            LenValue = 0;
            byte[] send = new byte[10];
            //Data Format = { dataLen, devNo, dataCmd, dataVal, chkSum}
            //byte/s      = {    1   ,   1  ,    1   ,  2/3/4 ,   1   }
            int Len = 4;                                                    // 4 bytes = dataLen + devNo + dataCmd + chksum
            byte dataLen;                                                   // convert int to bytes after addition
            byte dataCmd = cmd;

            LenValue = 0;
            //calculate Frequency
            if (cmd == 0x21)
            {
                dataVal = cvyr_calFreq((int)paraNo);               //Calculation for DataLength 
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }
            //calculate the movement distance   
            else if (cmd == 0x12 || cmd == 0x13)
            {
                if (cmd == 0x13) { paraNo = paraNo - 50.000; }

                dataVal = cvyr_calDistance(Math.Round(paraNo, 3));
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }

            //Homing Pattern Number
            else if(cmd == 0x36)
            {
                dataVal = cvyr_homingPattern((int)paraNo);
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }

            else if (cmd == 0x60 || cmd == 0x61)
            {
                dataVal = cvyr_calVelocitySetting((int)paraNo);
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }

            else if (cmd == 0x62 || cmd == 0x63)
            {
                dataVal = cvyr_calAccTimeSetting((int)paraNo);
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }

            else if (cmd == 0x68 || cmd == 0x69)
            {
                dataVal = cvyr_calSpdSetting((int)paraNo);
                Len = Len + dataVal.Length;
                LenValue = dataVal.Length;
            }

            dataLen = Convert.ToByte(Len);                            //Convert TO BYTE

            //Calculation for CheckSum
            //set current data format except of CheckSum data
            for (i = 0; i < 3 + LenValue; i++)
            {
                if (i == 0) { send[i] = dataLen; }
                else if (i == 1) { send[i] = devNo; }
                else if (i == 2) { send[i] = dataCmd; }
                else if (i > 2) { if (LenValue > 0) { send[i] = dataVal[i - 3]; } }
            }

            //ChkSum
            //lower 4 bits
            for (i = 0; i < 3 + LenValue; i++)
            {
                tempj = send[i] ;                                 // only get Lower 4 bits
                lowerByte += Convert.ToByte(tempj);                     // do addition for lower 4 bits and convert to byte
            }

            chksum = Convert.ToByte( lowerByte);         //sum Upper and Lower   upperByte +
            send[3 + LenValue] = chksum;                            //add Checksum value to Send Data Command

            Array.Resize(ref send, 4 + LenValue);                   //update byte size
            return send;
        }
        #endregion

        #region Send Data

        static byte[] rtnByte;
        //Function call
        public static byte[] Write(byte devNo, byte cmd, double paraNo)
        {

            switch (cmd)
            {
                case 0x00: //Reset   
                    rtnByte = cvyr_dataCommand(devNo, 0x00, 0);
                    break;

                case 0x01: //Initialzation
                    rtnByte = cvyr_dataCommand(devNo, 0x01, 0);
                    break;

                case 0x02: //Equipment Status Reading
                    rtnByte = cvyr_dataCommand(devNo, 0x02, 0);
                    break;

                case 0x04: //ASCII ID Reading
                    rtnByte = cvyr_dataCommand(devNo, 0x04, 0);
                    break;

                case 0x05: //Binary ID reading
                    rtnByte = cvyr_dataCommand(devNo, 0x05, 0);
                    break;

                case 0x10: //Homing Start
                    rtnByte = cvyr_dataCommand(devNo, 0x10, 0);
                    break;

                case 0x11: //Continous rotation start
                    rtnByte = cvyr_dataCommand(devNo, 0x11, paraNo);
                    break;

                case 0x12: //Relative Positioning Start
                    rtnByte = cvyr_dataCommand(devNo, 0x12, paraNo);
                    break;

                case 0x13: //Absolute Positioning Start
                    rtnByte = cvyr_dataCommand(devNo, 0x13, paraNo);
                    break;

                case 0x16: //Deceleration Stop
                    rtnByte = cvyr_dataCommand(devNo, 0x16, 0);
                    break;

                case 0x17: //Immediate Stop
                    rtnByte = cvyr_dataCommand(devNo, 0x17, 0);
                    break;

                case 0x20: //Current Position Setting
                    break;

                case 0x21: //Highest Frequency Setting
                    rtnByte = cvyr_dataCommand(devNo, 0x21, paraNo);
                    break;

                case 0x22: //Start-Up Frequency Setting
                    break;

                case 0x23: //Acceleration & Deceleration Rate Setting
                    break;

                case 0x25: //Homing Higest Frequnecy Setting
                    break;

                case 0x26: //Home Return Start Frequency Setting
                    break;

                case 0x27: //Origin search Frequency
                    break;

                case 0x28: //Homing Maxinum Time Setting
                    break;

                case 0x29: //Setting Homing Inversion time
                    break;

                case 0x2A: //Home Completion Position Setting
                    break;

                case 0x30: //Operating Current Setting
                    rtnByte = cvyr_dataCommand(devNo, 0x30, 0);
                    break;

                case 0x31: //Standstill current Setting
                    break;

                case 0x36: //Homing method Setting
                    rtnByte = cvyr_dataCommand(devNo, 0x36, paraNo);
                    break;

                case 0x39: //System Settings Completed
                    rtnByte = cvyr_dataCommand(devNo, 0x39, 0);
                    break;

                case 0x40: //Current Positon readout
                    rtnByte = cvyr_dataCommand(devNo, 0x40, 0);
                    break;

                case 0x41: //Current Speed Reading
                    rtnByte = cvyr_dataCommand(devNo, 0x41, 0);
                    break;

                case 0x42: //Abnormal Cause reading
                    rtnByte = cvyr_dataCommand(devNo, 0x42, 0);
                    break;

                case 0x48: //Setting Data Read
                    rtnByte = cvyr_dataCommand(devNo, 0x48, paraNo);
                    break;

                case 0x49: //Communication Log reading
                    rtnByte = cvyr_dataCommand(devNo, 0x49, 0);
                    break;

                case 0x50: //Excitation Control
                    rtnByte = cvyr_dataCommand(devNo, 0x50, paraNo);
                    break;

                case 0x60: //Speed Setting of High Speed
                    rtnByte = cvyr_dataCommand(devNo, 0x60, paraNo);     
                    break;

                case 0x61: //Speed Setting at Low Speed
                    break;

                case 0x62: // Setting Acceleration time
                    break;

                case 0x63: //Setting Deceleration time
                    break;

                case 0x68: //Operating Current Setting of High Speed
                    break;

                case 0x69: //Operating Current Setting at Low Speed
                    break;

                case 0x6A: //Deceleration delay pulse setting
                    break;

                case 0x6B: //Number of Deceleration of Pulse Setting
                    break;

                case 0x6C: //Transport relative position Pulse Setting
                    break;

                case 0x6F: //Positioning Additional Pulse Setting
                    break;
            }
            return rtnByte;
        }
        #endregion

        #region Send Data
        public static void Send(byte[] data)
        {
            SerialCOM.Write(data, 0, data.Length);
            Thread.Sleep(100); // wait for data received
        }
        #endregion

        #region Receive Data
        public static string Receive_String()
        {
            string msg ; //=SerialCOM.hex;
            msg = SerialCOM.read_data_String;
            return msg;
        }

        public static byte[] Receive_Bytes()
        {
            byte[] msg;
            msg = SerialCOM.read_data_Bytes;
            return msg;
        }

        #endregion

        #region Motor Status Check
        public static UInt32 chkIOstatus()
        {
            byte[] bytes;
            UInt32 ret;
            bytes = CVYR.Write(0x00, 0x02, 0);
            CVYR.Send(bytes);
            bytes = CVYR.Receive_Bytes();
            byte byteslow = bytes[3];
            
            byte byteshigh = bytes[4];
            byte[] output = { byteslow, byteshigh, 0x00, 0x00 };

            ret = BitConverter.ToUInt32(output, 0);
            return ret;
        }
        #endregion
    }
}
